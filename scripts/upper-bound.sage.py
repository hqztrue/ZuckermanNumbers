

# This file was *autogenerated* from the file upper-bound.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_10 = Integer(10); _sage_const_8 = Integer(8); _sage_const_3 = Integer(3); _sage_const_20 = Integer(20)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

def zeta(D, s):
    return sum(d**-s for d in D)

def zeta1(D, s):
    return -sum(log(d)*d**-s for d in D)

def Omega(b):
    O = []
    for p in prime_factors(b):
        D = []
        for d in range(_sage_const_1 , b):
            if not p.divides(d):
                D.append(d)
        O.append(D)
    return O

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

def F(b, D, v, s):
    return log(zeta(D, s) * b**s) / (log(len(D)**v * b**s))

def G(b, D, v, s):
    return (s + v*log(len(D))/log(b))*zeta1(D, s)/zeta(D, s) - log(zeta(D, s)/len(D)**v)

def F1(b, D, v, s):
    return G(b, D, v, s) * log(b)/(log(len(D)**v * b**s))**_sage_const_2 

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

def min_F(b, D, v):

    # Note: F(s) has derivative
    # F'(s) = G(s)*log(b)/(log(len(D)^v * b^s))^2
    # where G is monotone increasing.
    # Therefore, by the mean value theorem, we have that
    # |F(s) - F(s0)| <= |(s - s0)*G(s_max)*log(b)/(log(len(D)^v * b^s_min))^2|
    # for all s_min <= s, s0 <= s_max.

    s_min = _sage_const_0 
    s_max = _sage_const_1 
    eps = _sage_const_10 **-_sage_const_8 
    
    while G(b, D, v, s_max) <= _sage_const_0 :
        s_max *= _sage_const_2 

    while True:
        s = (s_min + s_max) / _sage_const_2 
        
        if G(b, D, v, s) > _sage_const_0 :
            s_max = s
        else:
            s_min = s

        if abs((s_max - s_min) * G(b, D, v, s_max) * log(b)/(log(len(D)**v * b**s_min))**_sage_const_2 ) < eps:
            break

    return F(b, D, v, s)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

def UpperBoundExponent(b):
    return max((log(len(D))/log(b))*min_F(b, D, _sage_const_1 ) for D in Omega(b))

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

print("b \t z_b^+ \n------------------")    
for b in range(_sage_const_3 , _sage_const_20 +_sage_const_1 ):
    print(b, "\t", N(UpperBoundExponent(b)))

